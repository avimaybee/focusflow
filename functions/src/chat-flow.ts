/* eslint-disable max-len */
"use server";

import {ai, getModel} from "./genkit";
import {marked} from "marked";
import {
  createDiscussionPromptsTool,
  createFlashcardsTool,
  createMemoryAidTool,
  createQuizTool,
  createStudyPlanTool,
  explainConceptTool,
  highlightKeyInsightsTool,
  summarizeNotesTool,
} from "./tools";
import {ChatInput, ChatInputSchema, ChatOutputSchema} from "@/types/chat-types";
import {
  doc,
  getDoc,
  collection,
  addDoc,
  serverTimestamp,
} from "firebase/firestore";
import {db} from "@/lib/firebase";
import {PersonaIDs} from "@/lib/constants";
import {
  ToolRequestPart,
  genkitToolAuth,
  UserFacingError,
} from "genkit/beta";
import {FirestoreSessionStore} from "@/lib/firestore-session-store";
import { indexAndAnswer } from "./rag-flow";

/**
 * Retrieves a persona prompt from Firestore based on the provided persona ID.
 * @param {string} personaId - The ID of the persona to retrieve.
 * @return {Promise<string>} The persona's prompt or a fallback prompt.
 */
async function getPersonaPrompt(personaId: string): Promise<string> {
  const personaRef = doc(db, "personas", personaId);
  const personaSnap = await getDoc(personaRef);
  if (personaSnap.exists()) {
    return personaSnap.data().prompt;
  }
  // Fallback to a neutral prompt if the persona is not found
  const fallbackRef = doc(db, "personas", PersonaIDs.NEUTRAL);
  const fallbackSnap = await getDoc(fallbackRef);
  if (fallbackSnap.exists()) {
    return fallbackSnap.data().prompt;
  }
  return "You are a helpful AI study assistant. Your tone is knowledgeable, " +
    "encouraging, and clear. You provide direct and effective help " +
    "without a strong personality. Your goal is to be a reliable and " +
    "straightforward academic tool.";
}

/**
 * Saves content generated by an AI tool to Firestore.
 * @param {string} userId - The ID of the user.
 * @param {string} toolName - The name of the tool that generated the content.
 * @param {unknown} output - The output from the tool.
 * @param {unknown} toolInput - The input that was passed to the tool.
 */
async function saveGeneratedContent(
  userId: string,
  toolName: string,
  output: unknown,
  toolInput: unknown
) {
  if (!userId || !toolName || !output || !toolInput) return;

  let collectionName = "";
  let sourceText = "";

  // Determine the source text based on the tool that was called
  switch (toolName) {
  case "summarizeNotesTool":
    collectionName = "summaries";
    sourceText = (toolInput as {notes: string}).notes;
    break;
  case "createFlashcardsTool":
    collectionName = "flashcardSets";
    sourceText = (toolInput as {topic: string}).topic;
    break;
  case "createQuizTool":
    collectionName = "quizzes";
    sourceText = (toolInput as {topic: string}).topic;
    break;
  case "createStudyPlanTool":
    collectionName = "studyPlans";
    sourceText = (toolInput as {topic: string}).topic;
    break;
  case "highlightKeyInsightsTool":
    collectionName = "insights"; // Assuming a collection name
    sourceText = (toolInput as {text: string}).text;
    break;
  default:
    return; // Don't save for tools that don't generate persistent content
  }

  const data: Record<string, unknown> = {
    sourceText: sourceText,
    createdAt: serverTimestamp(),
  };

  // Add tool-specific data
  switch (toolName) {
  case "summarizeNotesTool":
    data.title = (output as {title: string}).title || "Summary";
    data.summary = (output as {summary: string}).summary;
    data.keywords = (output as {keywords: string[]}).keywords;
    break;
  case "createFlashcardsTool":
    data.title = `Flashcards for: ${sourceText.substring(0, 40)}...`;
    data.flashcards = (output as {flashcards: unknown[]}).flashcards;
    break;
  case "createQuizTool":
    data.title =
        (output as {title?: string}).title ||
        `Quiz for: ${sourceText.substring(0, 40)}...`;
    data.quiz = (output as {quiz: unknown}).quiz;
    break;
  case "createStudyPlanTool":
    data.title =
        (output as {title?: string}).title || "New Study Plan";
    data.plan = (output as {plan: unknown}).plan;
    break;
  case "highlightKeyInsightsTool":
    data.title = `Key Insights for: ${sourceText.substring(0, 40)}...`;
    data.insights = (output as {insights: string[]}).insights;
    break;
  }

  try {
    const contentCollection = collection(db, "users", userId, collectionName);
    await addDoc(contentCollection, data);
    console.log(`Saved ${collectionName} for user ${userId}`);
  } catch (error) {
    console.error(`Error saving ${collectionName} to Firestore:`, error);
  }
}

export const chatFlow = ai.defineFlow(
  {
    name: "chatFlow",
    inputSchema: ChatInputSchema,
    outputSchema: ChatOutputSchema,
    auth: genkitToolAuth((auth) => {
      if (!auth) {
        throw new UserFacingError(
          "UNAUTHENTICATED",
          "You must be logged in to use this feature."
        );
      }
      console.log(`Authorizing user: ${auth.uid}`);
    }),
  },
  async (input: ChatInput, {auth, streamingCallback}) => {
    const {message, context, persona, sessionId: chatSessionId} = input;

    if (!auth?.uid) {
      throw new UserFacingError(
        "UNAUTHENTICATED",
        "Authentication is required."
      );
    }

    // Handle PDF context using the RAG flow
    if (context && context.startsWith("data:application/pdf")) {
        try {
            const answer = await indexAndAnswer({
                document: context,
                question: message,
            });
            const formattedResponse = await marked(answer);
            return {
                response: formattedResponse,
                rawResponse: answer,
                sessionId: chatSessionId, // RAG flow is stateless for now
            };
        } catch (e) {
            console.error("Error in RAG flow", e);
            throw new UserFacingError("RAG_ERROR", "Sorry, I had trouble reading that PDF. Please try again.");
        }
    }

    const model = getModel("googleai/gemini-1.5-flash");
    const personaInstruction = await getPersonaPrompt(persona);
    const systemPrompt =
      `${personaInstruction} You are an expert AI assistant and a helpful, ` +
      "conversational study partner. Your responses should be " +
      "well-structured and use markdown for formatting (e.g., headings, " +
      "bold text, lists) to improve readability. If you need information " +
      "from the user to use a tool (like source text for a quiz), and the " +
      "user does not provide it, you must explain clearly why you need it " +
      "and suggest ways the user can provide it (like pasting text or " +
      "uploading a file). Do not try to use a tool without the required " +
      "information.";

    const availableTools = [
      summarizeNotesTool,
      createStudyPlanTool,
      createFlashcardsTool,
      createQuizTool,
      explainConceptTool,
      createMemoryAidTool,
      createDiscussionPromptsTool,
      highlightKeyInsightsTool,
    ];

    const sessionId = `${auth.uid}_${chatSessionId || crypto.randomUUID()}`;

    try {
      const chat = await ai.chat({
        model,
        tools: availableTools,
        system: systemPrompt,
        sessionId: sessionId,
        store: new FirestoreSessionStore(),
      });

      const userMessageContent: ToolRequestPart[] = [{text: message}];

      if (context) {
        const isDataUri = context.startsWith("data:");
        if (isDataUri) {
          const [header, base64Data] = context.split(",");
          const mimeType = header.split(":")[1].split(";")[0];
          if (mimeType.startsWith("image/")) {
            userMessageContent.push({
              media: {
                url: context,
                contentType: mimeType,
              },
            });
          } else if (!mimeType.includes("pdf")) { // PDFs handled above
            let textContent = "";
            const buffer = Buffer.from(base64Data, "base64");
            textContent = buffer.toString("utf-8");
            const fileContext = `FILE CONTENT:\n${textContent}\n\n`;
            userMessageContent[0] = {
              text: `${fileContext}USER'S REQUEST:\n${message}`,
            };
          }
        } else {
          const fileContext = `CONTEXT:\n${context}\n\n`;
          userMessageContent[0] = {
            text: `${fileContext}USER'S REQUEST:\n${message}`,
          };
        }
      }

      const result = await chat.send(userMessageContent, {streamingCallback});

      const choices = result.candidates;

      if (!choices || choices.length === 0) {
        throw new Error("AI model did not return a response.");
      }

      const winningChoice = choices[0];

      if (
        winningChoice.finishReason &&
        winningChoice.finishReason !== "stop" &&
        winningChoice.finishReason !== "other"
      ) {
        console.warn(
          `AI response stopped for reason: ${winningChoice.finishReason}`
        );
        if (winningChoice.finishReason === "safety") {
          return {
            response:
              "I am sorry, but I cannot provide a response that violates " +
              "safety policies. Please rephrase your request.",
            rawResponse: "Response blocked due to safety settings.",
            isError: true,
          };
        }
      }

      if (winningChoice.toolCalls && winningChoice.toolCalls.length > 0) {
        for (const toolCall of winningChoice.toolCalls) {
          const toolName = toolCall.name;
          if (toolCall.output && auth?.uid) {
            await saveGeneratedContent(
              auth.uid,
              toolName,
              toolCall.output,
              toolCall.input
            );
          }
        }
      }

      const responseText =
        result.text() || "Sorry, I am not sure how to help with that.";
      const formattedResponse = await marked(responseText);

      return {
        response: formattedResponse,
        rawResponse: responseText,
        sessionId: result.sessionId.split("_")[1],
      };
    } catch (error: unknown) {
      console.error("Error in ai.generate:", error);

      if (error instanceof UserFacingError) {
        return {
          response: error.message,
          rawResponse: error.message,
          isError: true,
        };
      }

      const errorMessage =
        "Sorry, there was an unexpected error processing your " +
        "request. Please try again later.";

      return {
        response: errorMessage,
        rawResponse: errorMessage,
        isError: true,
      };
    }
  }
);
